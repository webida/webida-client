/*
 * Copyright (c) 2012-2015 S-Core Co., Ltd.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

describe("HTMLInspector", function() {

  var originalRules = HTMLInspector.rules
    , originalModules = HTMLInspector.modules
    , html = parseHTML(''
        + '<section class="section">'
        + '  <h1 id="heading" class="multiple classes">Heading</h1>'
        + '  <p class="first">One</p>'
        + '  <p><a href="#">More</a></p>'
        + '  <blockquote data-foo="bar" onclick="somefunc()">'
        + '    <p style="display: inline;">Nested</p>'
        + '    <p class="stuff">Stuff'
        + '      <em id="emphasis" data-bar="foo">lolz</em>'
        + '    </p>'
        + '  </blockquote>'
        + '</section>'
      )

  beforeEach(function() {
    // remove all rule and modules
    HTMLInspector.rules = new originalRules.constructor()
    HTMLInspector.modules = new originalModules.constructor()
  })

  afterEach(function() {
    // restore all rules and modules
    HTMLInspector.rules = originalRules
    HTMLInspector.modules = originalModules
  })

  describe(".inspect", function() {

    it("inspects the HTML starting from the specified domRoot", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("element", function(name) {
          events.push(name)
        })
      })
      HTMLInspector.inspect()
      expect(events[0]).to.equal("html")
      events = []
      HTMLInspector.inspect({ domRoot: html })
      expect(events[0]).to.equal("section")
    })

    it("only runs the specified rules (or all rules if none are specified)", function() {
      var rules = []
      HTMLInspector.rules.add("one", function(listener, reporter) {
        listener.on("beforeInspect", function(name) { rules.push("one") })
      })
      HTMLInspector.rules.add("two", function(listener, reporter) {
        listener.on("beforeInspect", function(name) { rules.push("two") })
      })
      HTMLInspector.rules.add("three", function(listener, reporter) {
        listener.on("beforeInspect", function(name) { rules.push("three") })
      })
      HTMLInspector.inspect()
      expect(rules.length).to.equal(3)
      expect(rules[0]).to.equal("one")
      expect(rules[1]).to.equal("two")
      expect(rules[2]).to.equal("three")
      rules = []
      HTMLInspector.inspect(["one"])
      expect(rules.length).to.equal(1)
      expect(rules[0]).to.equal("one")
      rules = []
      HTMLInspector.inspect(["one", "two"])
      expect(rules.length).to.equal(2)
      expect(rules[0]).to.equal("one")
      expect(rules[1]).to.equal("two")
    })

    it("excludes rules specifically mentioned in the `excludeRules` options", function() {
      var rules = []
      HTMLInspector.rules.add("one", function(listener, reporter) {
        listener.on("beforeInspect", function(name) { rules.push("one") })
      })
      HTMLInspector.rules.add("two", function(listener, reporter) {
        listener.on("beforeInspect", function(name) { rules.push("two") })
      })
      HTMLInspector.rules.add("three", function(listener, reporter) {
        listener.on("beforeInspect", function(name) { rules.push("three") })
      })
      HTMLInspector.inspect({
        excludeRules: ["one", "two"]
      })
      expect(rules.length).to.equal(1)
      expect(rules[0]).to.equal("three")
      rules = []
      HTMLInspector.inspect({
        useRules: ["one", "two"],
        excludeRules: ["two"]
      })
      expect(rules.length).to.equal(1)
      expect(rules[0]).to.equal("one")
    })

    it("ignores elements matching the `excludeElements` config option", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("element", function(name) {
          events.push(name)
        })
      })
      HTMLInspector.inspect({
        domRoot: html,
        excludeElements: ["h1", "p"]
      })
      expect(events).to.deep.equal(["section", "a", "blockquote", "em"])
      events = []
      HTMLInspector.inspect({
        domRoot: html,
        excludeElements: html.querySelector("blockquote")
      })
      expect(events).to.deep.equal(["section", "h1", "p", "p", "a", "p", "p", "em"])
    })

    it("ignores elements that descend from the `excludeSubTrees` config option", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("element", function(name) {
          events.push(name)
        })
      })
      HTMLInspector.inspect({
        domRoot: html,
        excludeSubTrees: "p"
      })
      expect(events).to.deep.equal(["section", "h1", "p", "p", "blockquote", "p", "p"])
      events = []
      HTMLInspector.inspect({
        domRoot: html,
        excludeSubTrees: [html.querySelector("p:not(.first)"), html.querySelector("blockquote")]
      })
      expect(events).to.deep.equal(["section", "h1", "p", "p", "blockquote"])
    })

    it("invokes the onComplete callback passing in an array of errors", function() {
      var log
      HTMLInspector.rules.add("one-two", function(listener, reporter) {
        reporter.warn("one-two", "This is the `one` error message", document)
        reporter.warn("one-two", "This is the `two` error message", document)

      })
      HTMLInspector.rules.add("three", function(listener, reporter) {
        reporter.warn("three", "This is the `three` error message", document)
      })
      HTMLInspector.inspect(function(errors) {
        log = errors
      })
      expect(log.length).to.equal(3)
      expect(log[0].message).to.equal("This is the `one` error message")
      expect(log[1].message).to.equal("This is the `two` error message")
      expect(log[2].message).to.equal("This is the `three` error message")
    })

    it("accepts a variety of types for the options paramter", function() {
      var log = []
        , div = document.createElement("div")
      HTMLInspector.rules.add("dom", function(listener, reporter) {
        listener.on("element", function(name) {
          log.push(this)
        })
      })
      HTMLInspector.rules.add("rules", function() {
        log.push("rules")
      })
      // if it's an object, assume it's the full config object
      HTMLInspector.inspect({
        useRules: ["dom"],
        domRoot: parseHTML("<p>foobar</p>"),
        onComplete: function(errors) {
          log.push("done")
        }
      })
      expect(log.length).to.equal(2)
      expect(log[0].innerHTML).to.equal("foobar")
      expect(log[1]).to.equal("done")
      log = []
      // if it's an array, assume it's a list of rules
      HTMLInspector.inspect(["dom"])
      expect(log.indexOf("rules")).to.equal(-1)
      log = []
      // if it's a string, assume it's a selector
      HTMLInspector.inspect("body")
      expect(log[1]).to.equal(document.body)
      log = []
      // if it's a DOM element, assume it's the domRoot
      HTMLInspector.inspect(div)
      expect(log[1]).to.equal(div)
      log = []
      // if it's a function, assume it's complete
      HTMLInspector.inspect(function(errors) {
        log = "func"
      })
      expect(log).to.equal("func")
    })

    it("triggers `beforeInspect` before the DOM traversal", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("beforeInspect", function() {
          events.push("beforeInspect")
        })
        listener.on("element", function() {
          events.push("element")
        })
      })
      HTMLInspector.inspect(html)
      expect(events.length).to.be.above(2)
      expect(events[0]).to.equal("beforeInspect")
      expect(events[1]).to.equal("element")
    })

    it("traverses the DOM emitting events for each element", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("element", function(name) {
          events.push(name)
        })
      })
      HTMLInspector.inspect(html)
      expect(events.length).to.equal(9)
      expect(events[0]).to.equal("section")
      expect(events[1]).to.equal("h1")
      expect(events[2]).to.equal("p")
      expect(events[3]).to.equal("p")
      expect(events[4]).to.equal("a")
      expect(events[5]).to.equal("blockquote")
      expect(events[6]).to.equal("p")
      expect(events[7]).to.equal("p")
      expect(events[8]).to.equal("em")
    })

    it("traverses the DOM emitting events for each id attribute", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("id", function(name) {
          events.push(name)
        })
      })
      HTMLInspector.inspect(html)
      expect(events.length).to.equal(2)
      expect(events[0]).to.equal("heading")
      expect(events[1]).to.equal("emphasis")
    })

    it("traverses the DOM emitting events for each class attribute", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("class", function(name) {
          events.push(name)
        })
      })
      HTMLInspector.inspect(html)
      expect(events.length).to.equal(5)
      expect(events[0]).to.equal("section")
      expect(events[1]).to.equal("multiple")
      expect(events[2]).to.equal("classes")
      expect(events[3]).to.equal("first")
      expect(events[4]).to.equal("stuff")
    })

    it("traverses the DOM emitting events for each attribute", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("attribute", function(name, value) {
          events.push({name:name, value:value})
        })
      })
      HTMLInspector.inspect(html)
      expect(events.length).to.equal(11)
      expect(events[0]).to.deep.equal({name:"class", value:"section"})
      expect(events[1]).to.deep.equal({name:"class", value:"multiple classes"})
      expect(events[2]).to.deep.equal({name:"id", value:"heading"})
      expect(events[3]).to.deep.equal({name:"class", value:"first"})
      expect(events[4]).to.deep.equal({name:"href", value:"#"})
      expect(events[5]).to.deep.equal({name:"data-foo", value:"bar"})
      expect(events[6]).to.deep.equal({name:"onclick", value:"somefunc()"})
      expect(events[7]).to.deep.equal({name:"style", value:"display: inline;"})
      expect(events[8]).to.deep.equal({name:"class", value:"stuff"})
      expect(events[9]).to.deep.equal({name:"data-bar", value:"foo"})
      expect(events[10]).to.deep.equal({name:"id", value:"emphasis"})
    })

    it("triggers `afterInspect` after the DOM traversal", function() {
      var events = []
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("afterInspect", function() {
          events.push("afterInspect")
        })
        listener.on("element", function() {
          events.push("element")
        })
      })
      HTMLInspector.inspect(html)
      expect(events.length).to.be.above(2)
      expect(events[events.length - 1]).to.equal("afterInspect")
    })

    it("ignores SVG elements and their children", function() {
      var events = []
        , div = document.createElement("div")
      HTMLInspector.rules.add("traverse-test", function(listener, reporter) {
        listener.on("element", function(name) {
          events.push(name)
        })
      })
      div.innerHTML = ""
        + '<svg viewBox="0 0 512 512" height="22" width="22">'
        + '  <path></path>'
        + '</svg>'
      HTMLInspector.inspect(div)
      expect(events.length).to.equal(1)
      expect(events[0]).to.equal("div")
    })

    it("logs warnings to the console by default when onComplete isn't overriden", function() {
      // stub out console.warn
      sinon.stub(console, "warn")

      HTMLInspector.rules.add("console-warn-test", function(listener, reporter) {
        listener.on("element", function(name) {
          reporter.warn("console-warn-test", "Element found", this)
        })
      })

      HTMLInspector.inspect(html)
      expect(console.warn.callCount).to.equal(9)
      expect(console.warn.getCall(0).args[0]).to.equal("Element found")
      expect(console.warn.getCall(0).args[1]).to.equal(html)

      console.warn.restore()
    })

    it("does not console.warn cross-domain iframe elements", function() {
      var div = document.createElement("div")
        , iframe1 = document.createElement("iframe")
        , iframe2 = document.createElement("iframe")

      iframe1.src = "http://example.com"
      iframe2.src = "foobar.html"
      div.appendChild(iframe1)
      div.appendChild(iframe2)

      // stub out console.warn
      sinon.stub(console, "warn")

      HTMLInspector.rules.add("cross-domain-test", function(listener, reporter) {
        listener.on("element", function(name) {
          reporter.warn("cross-domain-test", "This is a cross-origin iframe", this)
        })
      })
      HTMLInspector.inspect(div)
      expect(console.warn.callCount).to.equal(3)
      expect(console.warn.getCall(1).args[1]).to.equal("(can't display iframe with cross-origin source: http://example.com/)")
      expect(console.warn.getCall(2).args[1]).to.equal(iframe2)
      console.warn.restore()
    })

  })

})

describe("Modules", function() {

describe("css", function() {

  var css = HTMLInspector.modules.css
    , originalStyleSheets = css.styleSheets
    , classes = ["alpha", "bar", "bravo", "charlie", "delta", "echo", "foo", "importee"]

  afterEach(function() {
    css.styleSheets = originalStyleSheets
  })

  it("can filter the searched style sheets via the styleSheets selector", function() {
    css.styleSheets = "#mocha-css"
    var classes = css.getClassSelectors()
    // limiting the style sheets to only mocha.css means
    // .alpha, .bravo, and .charlie won't be there
    expect(classes.indexOf("alpha")).to.equal(-1)
    expect(classes.indexOf("bravo")).to.equal(-1)
    expect(classes.indexOf("charlie")).to.equal(-1)
  })

  it("can get all the class selectors in the style sheets", function() {
    css.styleSheets = 'link[rel="stylesheet"]:not(#mocha-css)'
    expect(css.getClassSelectors().sort()).to.deep.equal(classes)
  })

  it("can include both <link> and <style> elements", function() {
    var extraClasses = classes.concat(["style", "fizz", "buzz"]).sort()
      , head = document.querySelector("head")
      , styles = parseHTML(""
          + "<style id='style'>"
          + "  .style .foo, .style .bar { visiblility: visible }"
          + "  .style .fizz, .style .buzz { visiblility: visible }"
          + "</style>"
        )

    // first remove any style tags that browser plugins might be putting in
    Array.prototype.slice.call(document.querySelectorAll("style")).forEach(function(el) {
      el.parentNode.removeChild(el)
    })

    head.appendChild(styles)

    css.styleSheets = 'link[rel="stylesheet"]:not(#mocha-css), style'
    expect(css.getClassSelectors().sort()).to.deep.equal(extraClasses)
    head.removeChild(styles)
  })

})

describe("validation", function() {

  var validation = HTMLInspector.modules.validation
    , originalElementWhitelist = validation.elementWhitelist
    , originalAttributeWhitelist = validation.attributeWhitelist

  afterEach(function() {
    validation.elementWhitelist = originalElementWhitelist
    validation.attributeWhitelist = originalAttributeWhitelist
  })

  it("can determine if an element is a valid HTML element", function() {
    expect(validation.isElementValid("p")).to.equal(true)
    expect(validation.isElementValid("time")).to.equal(true)
    expect(validation.isElementValid("bogus")).to.equal(false)
    expect(validation.isElementValid("hgroup")).to.equal(false)
  })

  it("can determine if an element is obsolete", function() {
    expect(validation.isElementObsolete("p")).to.equal(false)
    expect(validation.isElementObsolete("bogus")).to.equal(false)
    expect(validation.isElementObsolete("hgroup")).to.equal(true)
    expect(validation.isElementObsolete("blink")).to.equal(true)
    expect(validation.isElementObsolete("center")).to.equal(true)
  })

  it("can determine if an attribute is allowed on an element", function() {
    expect(validation.isAttributeValidForElement("href", "a")).to.equal(true)
    expect(validation.isAttributeValidForElement("aria-foobar", "nav")).to.equal(true)
    expect(validation.isAttributeValidForElement("data-stuff", "section")).to.equal(true)
    expect(validation.isAttributeValidForElement("href", "button")).to.equal(false)
    expect(validation.isAttributeValidForElement("placeholder", "select")).to.equal(false)
  })

  it("can determine if an attribute is obsolute for an element", function() {
    expect(validation.isAttributeObsoleteForElement("align", "div")).to.equal(true)
    expect(validation.isAttributeObsoleteForElement("bgcolor", "body")).to.equal(true)
    expect(validation.isAttributeObsoleteForElement("border", "img")).to.equal(true)
    expect(validation.isAttributeObsoleteForElement("href", "div")).to.equal(false)
    expect(validation.isAttributeObsoleteForElement("charset", "meta")).to.equal(false)
  })

  it("can determine if an attribute is required for an element", function() {
    expect(validation.isAttributeRequiredForElement("src", "img")).to.equal(true)
    expect(validation.isAttributeRequiredForElement("alt", "img")).to.equal(true)
    expect(validation.isAttributeRequiredForElement("action", "form")).to.equal(true)
    expect(validation.isAttributeRequiredForElement("rows", "textarea")).to.equal(true)
    expect(validation.isAttributeRequiredForElement("cols", "textarea")).to.equal(true)
    expect(validation.isAttributeRequiredForElement("id", "div")).to.equal(false)
    expect(validation.isAttributeRequiredForElement("target", "a")).to.equal(false)
  })

  it("can get a list of required attribute given an element", function() {
    expect(validation.getRequiredAttributesForElement("img")).to.deep.equal(["alt", "src"])
    expect(validation.getRequiredAttributesForElement("optgroup")).to.deep.equal(["label"])
    expect(validation.getRequiredAttributesForElement("form")).to.deep.equal(["action"])
    expect(validation.getRequiredAttributesForElement("div")).to.deep.equal([])
  })

  it("can determine if a child elememnt is allowed inside it's parent", function() {
    expect(validation.isChildAllowedInParent("div", "ul")).to.equal(false)
    expect(validation.isChildAllowedInParent("div", "span")).to.equal(false)
    expect(validation.isChildAllowedInParent("section", "em")).to.equal(false)
    expect(validation.isChildAllowedInParent("title", "body")).to.equal(false)
    expect(validation.isChildAllowedInParent("strong", "p")).to.equal(true)
    expect(validation.isChildAllowedInParent("li", "ol")).to.equal(true)
    expect(validation.isChildAllowedInParent("fieldset", "form")).to.equal(true)
    expect(validation.isChildAllowedInParent("td", "tr")).to.equal(true)
  })

  it("ignores elements that are whitelisted", function() {
    validation.elementWhitelist = validation.elementWhitelist.concat(["foo", "bar", "font", "center"])
    // valid elements
    expect(validation.isElementValid("foo")).to.equal(true)
    expect(validation.isElementValid("bar")).to.equal(true)
    // obsolete elements
    expect(validation.isElementObsolete("font")).to.equal(false)
    expect(validation.isElementObsolete("center")).to.equal(false)
  })

  it("ignores attributes that are whitelisted", function() {
    validation.attributeWhitelist = validation.attributeWhitelist.concat(["src", "placeholder", "align", /^bg[a-z]+$/])
    // valid elements
    expect(validation.isAttributeValidForElement("placeholder", "select")).to.equal(true)
    expect(validation.isAttributeValidForElement("ng-model", "div")).to.equal(true)
    // obsolete elements
    expect(validation.isAttributeObsoleteForElement("align", "div")).to.equal(false)
    expect(validation.isAttributeObsoleteForElement("bgcolor", "body")).to.equal(false)
    // required attributes
    expect(validation.isAttributeRequiredForElement("src", "img")).to.equal(false)

  })

})
})

describe("Rules", function() {

describe("bem-conventions", function() {

  var log
    , originalConfig = HTMLInspector.rules["bem-conventions"].config

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  afterEach(function() {
    HTMLInspector.rules["bem-conventions"].config.methodology = "suit"
  })

  describe("config", function() {

    var config = HTMLInspector.rules["bem-conventions"].config

    it("can take a BEM modifier or element class and returns its block's class name", function() {
      expect(config.getBlockName("Block--modifier")).to.equal("Block")
      expect(config.getBlockName("BlockName--someModifier")).to.equal("BlockName")
      expect(config.getBlockName("Block-element")).to.equal("Block")
      expect(config.getBlockName("BlockName-subElement")).to.equal("BlockName")
      expect(config.getBlockName("BlockName-subElement--modifierName")).to.equal("BlockName-subElement")
      expect(config.getBlockName("BlockName")).to.equal(false)
      expect(config.getBlockName("Foo---bar")).to.equal(false)
      expect(config.getBlockName("Foo--bar--baz")).to.equal(false)
      // the second convention
      config.methodology = "inuit"
      expect(config.getBlockName("block--modifier")).to.equal("block")
      expect(config.getBlockName("block-name--some-modifier")).to.equal("block-name")
      expect(config.getBlockName("block__element")).to.equal("block")
      expect(config.getBlockName("block-name__sub-element")).to.equal("block-name")
      expect(config.getBlockName("block-name__sub-element--modifier-name")).to.equal("block-name__sub-element")
      expect(config.getBlockName("block-name")).to.equal(false)
      expect(config.getBlockName("foo---bar")).to.equal(false)
      expect(config.getBlockName("foo--bar__baz")).to.equal(false)
      // the third convention
      config.methodology = "yandex"
      expect(config.getBlockName("block_modifier")).to.equal("block")
      expect(config.getBlockName("block-name_some_modifier")).to.equal("block-name")
      expect(config.getBlockName("block__element")).to.equal("block")
      expect(config.getBlockName("block-name__sub-element")).to.equal("block-name")
      expect(config.getBlockName("block-name__sub-element_modifier_name")).to.equal("block-name__sub-element")
      expect(config.getBlockName("block-name")).to.equal(false)
      expect(config.getBlockName("foo___bar")).to.equal(false)
      expect(config.getBlockName("foo_bar__baz")).to.equal(false)
    })

    it("can determine if a class is a block element class", function() {
      expect(config.isElement("Block-element")).to.equal(true)
      expect(config.isElement("BlockName-elementName")).to.equal(true)
      expect(config.isElement("Block--modifier")).to.equal(false)
      expect(config.isElement("BlockName--modifierName")).to.equal(false)
      expect(config.isElement("Block--modifier-stuffz")).to.equal(false)
      expect(config.isElement("Block--modifier--stuffz")).to.equal(false)
      // the second convention
      config.methodology = "inuit"
      expect(config.isElement("block__element")).to.equal(true)
      expect(config.isElement("block-name__element-name")).to.equal(true)
      expect(config.isElement("block--modifier")).to.equal(false)
      expect(config.isElement("block-name--modifier-name")).to.equal(false)
      expect(config.isElement("block__element__sub-element")).to.equal(false)
      expect(config.isElement("block--modifier--stuffz")).to.equal(false)
      // the third convention
      config.methodology = "yandex"
      expect(config.isElement("block__element")).to.equal(true)
      expect(config.isElement("block-name__element-name")).to.equal(true)
      expect(config.isElement("block_modifier")).to.equal(false)
      expect(config.isElement("block-name_modifier_name")).to.equal(false)
      expect(config.isElement("block__element__sub-element")).to.equal(false)
      expect(config.isElement("block_modifier_stuffz")).to.equal(false)
    })

    it("can determine if a class is a block modifier class", function() {
      expect(config.isModifier("Block--modifier")).to.equal(true)
      expect(config.isModifier("BlockName--modifierName")).to.equal(true)
      expect(config.isModifier("BlockName-elementName--modifierName")).to.equal(true)
      expect(config.isModifier("Block-element")).to.equal(false)
      expect(config.isModifier("BlockName-elementName")).to.equal(false)
      expect(config.isModifier("Block--modifier-stuffz")).to.equal(false)
      expect(config.isModifier("Block--modifier--stuffz")).to.equal(false)
      // the second convention
      config.methodology = "inuit"
      expect(config.isModifier("block--modifier")).to.equal(true)
      expect(config.isModifier("block-name--modifier-name")).to.equal(true)
      expect(config.isModifier("block-name__element-name--modifier-name")).to.equal(true)
      expect(config.isModifier("block__element")).to.equal(false)
      expect(config.isModifier("block-name__element-name")).to.equal(false)
      expect(config.isModifier("block--modifierStuffz")).to.equal(false)
      // the third convention
      config.methodology = "yandex"
      expect(config.isModifier("block_modifier")).to.equal(true)
      expect(config.isModifier("block-name_modifier_name")).to.equal(true)
      expect(config.isModifier("block-name__element-name_modifier_name")).to.equal(true)
      expect(config.isModifier("block__element")).to.equal(false)
      expect(config.isModifier("block-name__element-name")).to.equal(false)
      expect(config.isModifier("block_modifierStuffz")).to.equal(false)
    })

  })

  it("warns when a BEM element class is used when not the descendent of a block", function() {
    var html = parseHTML(''
          + '<div class="BlockOne SomeOtherBlock">'
          + '  <p class="BlockTwo-element">Foo</p>'
          + '  <p>Bar <em class="BlockThree-elementName">three</em></p>'
          + '</div>'
        )
    HTMLInspector.inspect({
      useRules: ["bem-conventions"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The BEM element 'BlockTwo-element' must be a descendent of 'BlockTwo'.")
    expect(log[1].message).to.equal("The BEM element 'BlockThree-elementName' must be a descendent of 'BlockThree'.")
    expect(log[0].context).to.equal(html.querySelector(".BlockTwo-element"))
    expect(log[1].context).to.equal(html.querySelector(".BlockThree-elementName"))
  })

  it("doesn't warn when a BEM element class is used as the descendent of a block", function() {
    var html = parseHTML(''
          + '<div class="BlockThree BlockTwo SomeOtherBlock">'
          + '  <p class="BlockTwo-element">Foo</p>'
          + '  <p>Bar <em class="BlockThree-elementName">three</em></p>'
          + '</div>'
        )
    HTMLInspector.inspect({
      useRules: ["bem-conventions"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("warns when a BEM modifier class is used without the unmodified block or element class", function() {
    var html = parseHTML(''
          + '<div class="BlockOne--active">'
          + '  <p class="BlockTwo--validName BlockThree SomeOtherBlock">Foo</p>'
          + '  <p class="Block-element--modified">Bar</p>'
          + '</div>'
        )
    HTMLInspector.inspect({
      useRules: ["bem-conventions"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(3)
    expect(log[0].message).to.equal("The BEM modifier class 'BlockOne--active' was found without the unmodified class 'BlockOne'.")
    expect(log[0].context).to.equal(html)
    expect(log[1].message).to.equal("The BEM modifier class 'BlockTwo--validName' was found without the unmodified class 'BlockTwo'.")
    expect(log[1].context).to.equal(html.querySelector(".BlockTwo--validName"))
    expect(log[2].message).to.equal("The BEM modifier class 'Block-element--modified' was found without the unmodified class 'Block-element'.")
    expect(log[2].context).to.equal(html.querySelector(".Block-element--modified"))
  })

  it("doesn't warn when a BEM modifier is used along with the unmodified block or element class", function() {
    var html = parseHTML(''
          + '<div class="BlockOne BlockOne--active">'
          + '  <p class="BlockTwo BlockTwo--validName SomeOtherBlock">Foo</p>'
          + '  <p>Bar</p>'
          + '</div>'
        )
    HTMLInspector.inspect({
      useRules: ["bem-conventions"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("allows for customization by altering the config object", function() {
    var html = parseHTML(''
          + '<div class="block-one">'
          + '  <p class="block-two---valid-name">Foo</p>'
          + '  <p class="block-three___element-name">Bar</p>'
          + '</div>'
        )
    HTMLInspector.rules.extend("bem-conventions", {
      methodology: {
        modifier: /^((?:[a-z]+\-)*[a-z]+(?:___(?:[a-z]+\-)*[a-z]+)?)\-\-\-(?:[a-z]+\-)*[a-z]+$/,
        element: /^((?:[a-z]+\-)*[a-z]+)___(?:[a-z]+\-)*[a-z]+$/
      }
    })
    HTMLInspector.inspect({
      useRules: ["bem-conventions"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The BEM modifier class 'block-two---valid-name' was found without the unmodified class 'block-two'.")
    expect(log[1].message).to.equal("The BEM element 'block-three___element-name' must be a descendent of 'block-three'.")
  })

})
describe("duplicate-ids", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when the same ID attribute is used more than once", function() {
    var html = parseHTML(''
          + '<div id="foobar">'
          + '  <p id="foobar">Foo</p>'
          + '  <p id="barfoo">bar <em id="barfoo">Em</em></p>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["duplicate-ids"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The id 'foobar' appears more than once in the document.")
    expect(log[1].message).to.equal("The id 'barfoo' appears more than once in the document.")
    expect(log[0].context).to.deep.equal([html, html.querySelector("p#foobar")])
    expect(log[1].context).to.deep.equal([html.querySelector("p#barfoo"), html.querySelector("em#barfoo")])

  })

  it("doesn't warn when all ids are unique", function() {
    var html = parseHTML(''
          + '<div id="foobar1">'
          + '  <p id="foobar2">Foo</p>'
          + '  <p id="barfoo1">Bar <em id="barfoo2">Em</em></p>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["duplicate-ids"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)
  })

})

describe("inline-event-handlers", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when inline event handlers are found on elements", function() {
    var html = parseHTML(''
          + '<div onresize="alert(\'bad!\')">'
          + '  <p>Foo</p>'
          + '  <p>Bar <a href="#" onclick="alert(\'bad!\')">click me</em></p>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["inline-event-handlers"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("An 'onresize' attribute was found in the HTML. Use external scripts for event binding instead.")
    expect(log[1].message).to.equal("An 'onclick' attribute was found in the HTML. Use external scripts for event binding instead.")
    expect(log[0].context).to.deep.equal(html)
    expect(log[1].context).to.deep.equal(html.querySelector("a"))

  })

  it("doesn't warn there are no inline event handlers", function() {
    var html = parseHTML(''
          + '<div>'
          + '  <p>Foo</p>'
          + '  <p>Bar <a href="#">click me</em></p>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["inline-event-handlers"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)
  })

})

describe("script-placement", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when script tags aren't found as the last elemenet in <body>", function() {
    HTMLInspector.inspect({
      useRules: ["script-placement"],
      onComplete: onComplete
    })
    expect(log.length).to.be.above(0)
    log.forEach(function(error, i) {
      expect(log[i].message).to.equal("<script> elements should appear right before the closing </body> tag for optimal performance.")
      expect(log[i].context.nodeName.toLowerCase()).to.equal("script")
    })

    var body = document.createElement("body")
    body.appendChild(parseHTML('<script id="script1">(function() { // script one }())</script>'))
    body.appendChild(parseHTML('<header>Header content</header>'))
    body.appendChild(parseHTML('<main>Main content</main>'))
    body.appendChild(parseHTML('<footer>Footer content</footer>'))
    body.appendChild(parseHTML('<script id="script2">(function() { // script two }())</script>'))
    body.appendChild(parseHTML('<script id="script3">(function() { // script three }())</script>'))

    // Make sure the scripts aren't async or defer
    Array.prototype.slice.call(body.querySelectorAll("script")).forEach(function(script) {
      script.async = false
      script.defer = false
    })

    HTMLInspector.inspect({
      useRules: ["script-placement"],
      domRoot: body,
      onComplete: onComplete
    })

    expect(log.length).to.equal(1)
    expect(log[0].message).to.equal("<script> elements should appear right before the closing </body> tag for optimal performance.")
    expect(log[0].context).to.equal(body.querySelector("#script1"))
  })

  it("doesn't warn when script tags are the last traversed element", function() {
    var body = document.createElement("body")
    body.appendChild(parseHTML('<header>Header content</header>'))
    body.appendChild(parseHTML('<main>Main content</main>'))
    body.appendChild(parseHTML('<footer>Footer content</header>'))
    body.appendChild(parseHTML('<script id="script1">(function() { // script one }())</script>'))
    body.appendChild(parseHTML('<script id="script2">(function() { // script two }())</script>'))

    HTMLInspector.inspect({
      useRules: ["script-placement"],
      domRoot: body,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("doesn't warn when the script uses either the async or defer attribute", function() {
    var body = document.createElement("body")
    body.appendChild(parseHTML('<script id="script1" async>(function() { // script one }())</script>'))
    body.appendChild(parseHTML('<script id="script2" defer>(function() { // script two }())</script>'))
    body.appendChild(parseHTML('<header>Header content</header>'))
    body.appendChild(parseHTML('<main>Main content</main>'))
    body.appendChild(parseHTML('<footer>Footer content</header>'))

    HTMLInspector.inspect({
      useRules: ["script-placement"],
      domRoot: body,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)

  })

  it("allows for customization by altering the config object", function() {
    var body = document.createElement("body")
    body.appendChild(parseHTML('<script id="script1">(function() { // script one }())</script>'))
    body.appendChild(parseHTML('<script id="script2">(function() { // script two }())</script>'))
    body.appendChild(parseHTML('<header>Header content</header>'))
    body.appendChild(parseHTML('<main>Main content</main>'))
    body.appendChild(parseHTML('<footer>Footer content</header>'))
    body.appendChild(parseHTML('<script id="script3">(function() { // script three }())</script>'))

    // Make sure the scripts aren't async or defer
    Array.prototype.slice.call(body.querySelectorAll("script")).forEach(function(script) {
      script.async = false
      script.defer = false
    })

    // whitelist #script1
    HTMLInspector.rules.extend("script-placement", {
      whitelist: "#script1"
    })
    HTMLInspector.inspect({
      useRules: ["script-placement"],
      domRoot: body,
      onComplete: onComplete
    })
    expect(log.length).to.equal(1)
    expect(log[0].message).to.equal("<script> elements should appear right before the closing </body> tag for optimal performance.")
    expect(log[0].context).to.equal(body.querySelector("#script2"))

    // whitelist #script1 and #script2
    HTMLInspector.rules.extend("script-placement", {
      whitelist: ["#script1", "#script2"]
    })
    HTMLInspector.inspect({
      useRules: ["script-placement"],
      domRoot: body,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })
})
describe("unique-elements", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when single-use elements appear on the page more than once", function() {
    var html = parseHTML(''
          + '<div>'
          + '  <div>'
          + '    <title>Foobar</title>'
          + '  </div>'
          + '  <div>'
          + '    <title>Foobar</title>'
          + '  </div>'
          + '  <header>Page Header</header>'
          + '  <header>Page Header</header>'
          + '  <main>Main content</main>'
          + '  <main>More main content</main>'
          + '  <footer>Footer content</header>'
          + '  <footer>Footer content</header>'
          + '</div>'
        )
    HTMLInspector.inspect({
      useRules: ["unique-elements"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The <title> element may only appear once in the document.")
    expect(log[1].message).to.equal("The <main> element may only appear once in the document.")
    expect(log[0].context).to.deep.equal([html.querySelector("title"), html.querySelectorAll("title")[1]])
    expect(log[1].context).to.deep.equal([html.querySelector("main"), html.querySelectorAll("main")[1]])
  })

  it("doesn't warn when single-use elements appear on the page only once", function() {
    var html = parseHTML(''
          + '<html>'
          + '  <head>'
          + '    <title>Foobar</title>'
          + '  </head>'
          + '  <body>'
          + '    <header>Header content</header>'
          + '    <main>Main content</main>'
          + '    <footer>Footer content</header>'
          + '  </body>'
          + '</html>'
        )
    HTMLInspector.inspect({
      useRules: ["unique-elements"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("allows for customization by altering the config object", function() {
    var html = parseHTML(''
          + '<div>'
          + '  <div>'
          + '    <title>Foobar</title>'
          + '  </div>'
          + '  <div>'
          + '    <title>Foobar</title>'
          + '  </div>'
          + '  <header>Page Header</header>'
          + '  <header>Page Header</header>'
          + '  <main>Main content</main>'
          + '  <main>More main content</main>'
          + '  <footer>Footer content</header>'
          + '  <footer>Footer content</header>'
          + '</div>'
        )
    HTMLInspector.rules.extend("unique-elements", {
      elements: ["header", "footer"]
    })
    HTMLInspector.inspect({
      useRules: ["unique-elements"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The <header> element may only appear once in the document.")
    expect(log[1].message).to.equal("The <footer> element may only appear once in the document.")
    expect(log[0].context).to.deep.equal([html.querySelector("header"), html.querySelectorAll("header")[1]])
    expect(log[1].context).to.deep.equal([html.querySelector("footer"), html.querySelectorAll("footer")[1]])
  })
})
describe("unnecessary-elements", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when unattributed <div> or <span> elements appear in the HTML", function() {
    var html = parseHTML(''
          + '<div>'
          + '  <span>Foo</span>'
          + '  <p>Foo</p>'
          + '  <div><b>Foo</b></div>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["unnecessary-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(3)
    expect(log[0].message).to.equal("Do not use <div> or <span> elements without any attributes.")
    expect(log[1].message).to.equal("Do not use <div> or <span> elements without any attributes.")
    expect(log[2].message).to.equal("Do not use <div> or <span> elements without any attributes.")
    expect(log[0].context).to.equal(html)
    expect(log[1].context).to.equal(html.querySelector("span"))
    expect(log[2].context).to.equal(html.querySelector("div"))

  })

  it("doesn't warn when attributed <div> or <span> elements appear in the HTML", function() {
    var html = parseHTML(''
          + '<div data-foo="bar">'
          + '  <span class="alert">Foo</span>'
          + '  <p>Foo</p>'
          + '  <div><b>Foo</b></div>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["unnecessary-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(1)
    expect(log[0].message).to.equal("Do not use <div> or <span> elements without any attributes.")
    expect(log[0].context).to.equal(html.querySelector("div"))

  })

  it("doesn't warn when unattributed, semantic elements appear in the HTML", function() {
    var html = parseHTML(''
          + '<section data-foo="bar">'
          + '  <h1>Foo</h1>'
          + '  <p>Foo</p>'
          + '</section>'
        )

    HTMLInspector.inspect({
      useRules: ["unnecessary-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)

  })

  it("allows for customization by altering the config object", function() {
    var html = parseHTML(''
          + '<div>'
          + '  <h1>Foo</h1>'
          + '  <span>Foo</span>'
          + '</div>'
        )
    HTMLInspector.rules.extend("unnecessary-elements", {
      isUnnecessary: function(element) {
        return element.nodeName === "SPAN"
      }
    })
    HTMLInspector.inspect({
      useRules: ["unnecessary-elements"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(1)
    expect(log[0].context).to.equal(html.querySelector("span"))

  })

})

describe("unused-classes", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when non-whitelisted classes appear in the HTML but not in any stylesheet", function() {
    var html = parseHTML(''
          + '<div class="fizz buzz">'
          + '  <p class="foo bar baz">This is just a test</p>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["unused-classes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log[0].message).to.equal("The class 'fizz' is used in the HTML but not found in any stylesheet.")
    expect(log[1].message).to.equal("The class 'buzz' is used in the HTML but not found in any stylesheet.")
    expect(log[2].message).to.equal("The class 'baz' is used in the HTML but not found in any stylesheet.")
    expect(log[0].context).to.equal(html)
    expect(log[1].context).to.equal(html)
    expect(log[2].context).to.equal(html.querySelector("p"))

  })

  it("doesn't warn when whitelisted classes appear in the HTML", function() {
    var html = parseHTML(''
          + '<div class="supports-flexbox">'
          + '  <p class="js-alert">This is just a test</p>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["unused-classes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)

  })

  it("allows for customization by altering the config object", function() {

    var html = parseHTML(''
          + '<div class="fizz supports-flexbox">'
          + '  <p class="js-alert buzz">This is just a test</p>'
          + '</div>'
        )

    // the whitelist can be a single RegExp
    HTMLInspector.rules.extend("unused-classes", {whitelist: /fizz|buzz/})

    HTMLInspector.inspect({
      useRules: ["unused-classes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The class 'supports-flexbox' is used in the HTML but not found in any stylesheet.")
    expect(log[1].message).to.equal("The class 'js-alert' is used in the HTML but not found in any stylesheet.")

    log = []
    // It can also be a list of strings or RegExps
    HTMLInspector.rules.extend("unused-classes", {whitelist: ["fizz", /buz\w/]})

    HTMLInspector.inspect({
      useRules: ["unused-classes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("The class 'supports-flexbox' is used in the HTML but not found in any stylesheet.")
    expect(log[1].message).to.equal("The class 'js-alert' is used in the HTML but not found in any stylesheet.")

  })

})

describe("validate-attributes", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when obsolete attributes of elements appear in the HTML", function() {

    var html = parseHTML(''
          + '<div align="center">'
          + '  <section>'
          + '     <h1>Title</h1>'
          + '     <h2 align="right">Subtitle</h2>'
          + '     <p>foo <br clear="both"> bar</p>'
          + '  </section>'
          + '  <hr color="red">'
          + '  <ul type="foo">'
          + '    <li>blah</li>'
          + '  </ul>'
          + '  <ol type="1">'
          + '    <li>blah</li>'
          + '  </ol>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-attributes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(5)
    expect(log[0].message).to.equal("The 'align' attribute is no longer valid on the <div> element and should not be used.")
    expect(log[0].context).to.equal(html)
    expect(log[1].message).to.equal("The 'align' attribute is no longer valid on the <h2> element and should not be used.")
    expect(log[1].context).to.equal(html.querySelector("h2"))
    expect(log[2].message).to.equal("The 'clear' attribute is no longer valid on the <br> element and should not be used.")
    expect(log[2].context).to.equal(html.querySelector("br"))
    expect(log[3].message).to.equal("The 'color' attribute is no longer valid on the <hr> element and should not be used.")
    expect(log[3].context).to.equal(html.querySelector("hr"))
    expect(log[4].message).to.equal("The 'type' attribute is no longer valid on the <ul> element and should not be used.")
    expect(log[4].context).to.equal(html.querySelector("ul"))

  })

  it("warns when invalid attributes of elements appear in the HTML", function() {

    var html = parseHTML(''
          + '<div foo="bar">'
          + '  <section action="http://example.com">'
          + '     <h1>Title</h1>'
          + '     <h2 cell-padding="1">Subtitle</h2>'
          + '     <p>foo <br blah="true"> bar</p>'
          + '  </section>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-attributes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(4)
    expect(log[0].message).to.equal("'foo' is not a valid attribute of the <div> element.")
    expect(log[0].context).to.equal(html)
    expect(log[1].message).to.equal("'action' is not a valid attribute of the <section> element.")
    expect(log[1].context).to.equal(html.querySelector("section"))
    expect(log[2].message).to.equal("'cell-padding' is not a valid attribute of the <h2> element.")
    expect(log[2].context).to.equal(html.querySelector("h2"))
    expect(log[3].message).to.equal("'blah' is not a valid attribute of the <br> element.")
    expect(log[3].context).to.equal(html.querySelector("br"))

  })

  it("warns when required attributes are missing", function() {

    var html = parseHTML(''
          + '<div>'
          + '  <img class="foo" />'
          + '  <form>'
          + '     <textarea><textarea>'
          + '  </form>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-attributes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(5)
    expect(log[0].message).to.equal("The 'alt' attribute is required for <img> elements.")
    expect(log[0].context).to.equal(html.querySelector("img"))
    expect(log[1].message).to.equal("The 'src' attribute is required for <img> elements.")
    expect(log[1].context).to.equal(html.querySelector("img"))
    expect(log[2].message).to.equal("The 'action' attribute is required for <form> elements.")
    expect(log[2].context).to.equal(html.querySelector("form"))
    expect(log[3].message).to.equal("The 'cols' attribute is required for <textarea> elements.")
    expect(log[3].context).to.equal(html.querySelector("textarea"))
    expect(log[4].message).to.equal("The 'rows' attribute is required for <textarea> elements.")
    expect(log[4].context).to.equal(html.querySelector("textarea"))

  })

  it("doesn't double-warn when an attribute is both invalid and obsolete", function() {

    var html = parseHTML(''
          + '<div align="center">'
          + '   <h1>Title</h1>'
          + '   <h2>Subtitle</h2>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-attributes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(1)
  })

  it("doesn't warn about invalid attributes if the element containing the attribute is invalid", function() {

    var html = parseHTML(''
          + '<div>'
          + '  <foo bar></foo>'
          + '  <fizz buzz="true"></fizz>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-attributes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)
  })

  it("doesn't warn when valid, non-obsolete elements are used", function() {

    var html = parseHTML(''
          + '<div class="foo" data-foo="bar" role="main">'
          + '  <span id="bar">Foo</span>'
          + '  <a aria-foo="bar" href="#">Foo</a>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-attributes"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)

  })


})
describe("validate-element-location", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when elements appear as children of parent elements they're not allow to be within", function() {

    var html = parseHTML(''
          + '<div>'
          + '  <h1>This is a <p>Heading!</p> shit</h1>'
          + '  <span>'
          + '    <ul>'
          + '      <li>foo</li>'
          + '    </ul>'
          + '  </span>'
          + '  <ul>'
          + '    <span><li>Foo</li></span>'
          + '    <li>Bar</li>'
          + '  </ul>'
          + '  <p>This is a <title>title</title> element</p>'
          + '  <em><p>emphasize!</p></em>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(6)
    expect(log[0].message).to.equal("The <p> element cannot be a child of the <h1> element.")
    expect(log[0].context).to.equal(html.querySelector("h1 > p"))
    expect(log[1].message).to.equal("The <ul> element cannot be a child of the <span> element.")
    expect(log[1].context).to.equal(html.querySelector("span > ul"))
    expect(log[2].message).to.equal("The <span> element cannot be a child of the <ul> element.")
    expect(log[2].context).to.equal(html.querySelector("ul > span"))
    expect(log[3].message).to.equal("The <li> element cannot be a child of the <span> element.")
    expect(log[3].context).to.equal(html.querySelector("span > li"))
    expect(log[4].message).to.equal("The <title> element cannot be a child of the <p> element.")
    expect(log[4].context).to.equal(html.querySelector("p > title"))
    expect(log[5].message).to.equal("The <p> element cannot be a child of the <em> element.")
    expect(log[5].context).to.equal(html.querySelector("em > p"))
  })

  it("doesn't warn when elements appear as children of parents they're allowed to be within", function() {
    var html = parseHTML(''
          + '<div>'
          + '  <h1>This is a <strong>Heading!</strong> shit</h1>'
          + '  <p><a href="#"><span></span></a><p>'
          + '  <ol><li><p>li</p></li></ol>'
          + '  <section>'
          + '    <article><h1>Blah</h1><p>This is some text</p></article>'
          + '  </section>'
          + '</div>'
        )
    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("warns when <style> elements inside body do not declare the scoped attribute", function() {
    var html = document.createElement("body")
    html.innerHTML = '<section><style> .foo { } </style></section>'

    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(1)
    expect(log[0].message).to.equal("<style> elements inside <body> must contain the 'scoped' attribute.")
    expect(log[0].context).to.equal(html.querySelector("style"))
  })

  it("doesn't warns when <style> elements are inside the head", function() {
    var html = parseHTML(''
          + '<html>'
          + '  <head>'
          + '    <style scoped> .foo { } </style>'
          + '  </head>'
          + '  <body></body>'
          + '</html>'
        )
    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("warns when <style> elements inside body declare the scoped attribute but are not the first child of their parent", function() {
    var html = document.createElement("body")
    html.innerHTML = '<section><span>alert</span><style scoped> .foo { } </style></section>'

    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(1)
    expect(log[0].message).to.equal("Scoped <style> elements must be the first child of their parent element.")
    expect(log[0].context).to.equal(html.querySelector("style"))
  })

  it("doesn't warns when <style scoped> elements are the first child of their parent", function() {
    var html = document.createElement("body")
    html.innerHTML = '<section><style scoped> .foo { } </style></section>'
    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

  it("warns when <link> and <meta> elements inside body do not declare the itemprop attribute", function() {
    var html = document.createElement("body")
    html.innerHTML = '<meta charset="utf-8"><link rel="imports" href="component.html">'
    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(2)
    expect(log[0].message).to.equal("<meta> elements inside <body> must contain the 'itemprop' attribute.")
    expect(log[0].context).to.equal(html.querySelector("meta"))
    expect(log[1].message).to.equal("<link> elements inside <body> must contain the 'itemprop' attribute.")
    expect(log[1].context).to.equal(html.querySelector("link"))
  })

  it("doesn't warns when <link> and <meta> elements are inside the head", function() {
    var html = parseHTML(''
          + '<html>'
          + '  <head>'
          + '    <meta charset="utf-8">'
          + '    <link rel="imports" href="component.html">'
          + '  </head>'
          + '  <body></body>'
          + '</html>'
        )
    HTMLInspector.inspect({
      useRules: ["validate-element-location"],
      domRoot: html,
      onComplete: onComplete
    })
    expect(log.length).to.equal(0)
  })

})
describe("validate-elements", function() {

  var log

  function onComplete(reports) {
    log = []
    reports.forEach(function(report) {
      log.push(report)
    })
  }

  it("warns when obsolete elements appear in the HTML", function() {

    var html = parseHTML(''
          + '<div>'
          + '  <hgroup>'
          + '     <h1>Title</h1>'
          + '     <h2>Subtitle</h2>'
          + '  </hgroup>'
          + '  <tt>Teletype text</tt>'
          + '  <center><p><b>Foo</b></p></center>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(3)
    expect(log[0].message).to.equal("The <hgroup> element is obsolete and should not be used.")
    expect(log[0].context).to.equal(html.querySelector("hgroup"))
    expect(log[1].message).to.equal("The <tt> element is obsolete and should not be used.")
    expect(log[1].context).to.equal(html.querySelector("tt"))
    expect(log[2].message).to.equal("The <center> element is obsolete and should not be used.")
    expect(log[2].context).to.equal(html.querySelector("center"))

  })

  it("warns when invalid elements appear in the HTML", function() {

    var html = parseHTML(''
          + '<div>'
          + '  <foo>'
          + '     <h1>Title</h1>'
          + '     <h2>Subtitle</h2>'
          + '  </foo>'
          + '  <bar>Teletype text</bar>'
          + '  <bogus><p><b>Foo</b></p></bogus>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(3)
    expect(log[0].message).to.equal("The <foo> element is not a valid HTML element.")
    expect(log[0].context).to.equal(html.querySelector("foo"))
    expect(log[1].message).to.equal("The <bar> element is not a valid HTML element.")
    expect(log[1].context).to.equal(html.querySelector("bar"))
    expect(log[2].message).to.equal("The <bogus> element is not a valid HTML element.")
    expect(log[2].context).to.equal(html.querySelector("bogus"))

  })

  it("doesn't double-warn when an element is both invalid and obsolete", function() {

    var html = parseHTML(''
          + '<hgroup>'
          + '   <h1>Title</h1>'
          + '   <h2>Subtitle</h2>'
          + '</hgroup>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(1)
  })

  it("doesn't warn when valid, non-obsolete elements are used", function() {

    var html = parseHTML(''
          + '<div>'
          + '  <span>Foo</span>'
          + '  <p>Foo</p>'
          + '  <div><b>Foo</b></div>'
          + '</div>'
        )

    HTMLInspector.inspect({
      useRules: ["validate-elements"],
      domRoot: html,
      onComplete: onComplete
    })

    expect(log.length).to.equal(0)

  })

})
})
